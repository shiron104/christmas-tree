<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Merry Christmas - 3D Experience</title>

  <!-- Fonts for Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet" />

  <!-- Three.js & Plugins -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Cinzel', serif;
    }

    /* Gradient Background - Evergreen Night */
    #bg-gradient {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, #0f2a18 0%, #030705 80%, #000000 100%);
      z-index: -1;
    }

    /* Overlay UI */
    #ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #title-box {
      margin-top: 5vh;
      text-align: center;
      opacity: 0;
      animation: fadeIn 3s ease-out forwards;
    }

    h1 {
      color: #ffffff;
      font-size: clamp(2.5rem, 6vw, 5rem);
      font-weight: 700;
      letter-spacing: 0.15em;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 30px rgba(255, 0, 50, 0.35);
      margin: 0;
    }

    canvas { touch-action: none; }

    @keyframes fadeIn {
      to { opacity: 1; }
    }
  </style>
</head>

<body>
  <div id="bg-gradient"></div>

  <!-- UI Overlay -->
  <div id="ui-container">
    <div id="title-box">
      <h1>MERRY CHRISTMAS</h1>
    </div>
  </div>

  <!-- Canvas -->
  <canvas id="webgl"></canvas>

  <!-- Audio -->
  <audio id="bg-music" loop>
    <source src="https://upload.wikimedia.org/wikipedia/commons/6/6c/Jingle_Bells_Kevin_MacLeod_-_No_Copyright_Music.mp3" type="audio/mpeg" />
  </audio>

  <script>
    // --- CONFIGURATION & IMAGE SOURCES ---
    const IMAGE_SOURCES = [
      'https://shiron104.github.io/christmas-tree/1.jpg',
      'https://shiron104.github.io/christmas-tree/2.jpg',
      'https://shiron104.github.io/christmas-tree/3.jpg',
      'https://shiron104.github.io/christmas-tree/5.jpg',
      'https://shiron104.github.io/christmas-tree/6.jpg'
    ];

    // --- THREE.JS SETUP ---
    const canvas = document.querySelector('#webgl');
    const scene = new THREE.Scene();

    // Green-tinted fog for tree vibe
    scene.fog = new THREE.FogExp2(0x07130c, 0.022);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 18);

    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

    // --- LIGHTING (Christmas Tree Theme: Evergreen + Warm Lights) ---
    const ambientLight = new THREE.AmbientLight(0x1b3a2a, 0.55);
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xffe2b8, 10);
    spotLight.position.set(10, 18, 10);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.6;
    spotLight.castShadow = true;
    spotLight.shadow.mapSize.width = 1024;
    spotLight.shadow.mapSize.height = 1024;
    scene.add(spotLight);

    // Warm fairy lights
    const fairy1 = new THREE.PointLight(0xffc76a, 4.0, 25);
    fairy1.position.set(-4, 2, 6);
    scene.add(fairy1);

    const fairy2 = new THREE.PointLight(0xffdca8, 3.5, 25);
    fairy2.position.set(5, -1, 4);
    scene.add(fairy2);

    const fairy3 = new THREE.PointLight(0xffb86b, 3.5, 25);
    fairy3.position.set(0, 6, -6);
    scene.add(fairy3);

    // Gentle accents
    const redAccent = new THREE.PointLight(0xff3b3b, 1.8, 18);
    redAccent.position.set(-6, 4, 0);
    scene.add(redAccent);

    const greenAccent = new THREE.PointLight(0x2cff8a, 1.2, 18);
    greenAccent.position.set(6, 1, -2);
    scene.add(greenAccent);

    // --- CONTROLS ---
    const controls = new THREE.OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    controls.minDistance = 5;
    controls.maxDistance = 30;
    controls.maxPolarAngle = Math.PI / 1.5;

    // --- MATERIALS (Warmer ornaments) ---
    const baseMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.22,
      metalness: 0.75,
      envMapIntensity: 1.1,
      emissive: new THREE.Color(0x1a1a1a),
      emissiveIntensity: 0.35
    });

    const sphereGeo = new THREE.SphereGeometry(0.15, 12, 12);
    const cubeGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
    const octaGeo = new THREE.OctahedronGeometry(0.6);

    // --- INSTANCED MESH DATA ---
    const COUNT = 1200;
    const SPHERE_COUNT = Math.floor(COUNT * 0.6);
    const CUBE_COUNT = COUNT - SPHERE_COUNT;

    const iMeshSpheres = new THREE.InstancedMesh(sphereGeo, baseMaterial, SPHERE_COUNT);
    const iMeshCubes = new THREE.InstancedMesh(cubeGeo, baseMaterial, CUBE_COUNT);

    iMeshSpheres.castShadow = true;
    iMeshSpheres.receiveShadow = true;
    iMeshCubes.castShadow = true;
    iMeshCubes.receiveShadow = true;

    const treeGroup = new THREE.Group();
    treeGroup.add(iMeshSpheres);
    treeGroup.add(iMeshCubes);
    scene.add(treeGroup);

    // --- IMAGE PLANE ---
    const textureLoader = new THREE.TextureLoader();
    const BASE_PLANE_W = 3.5;
    const BASE_PLANE_H = 4.5;

    const imageGeo = new THREE.PlaneGeometry(BASE_PLANE_W, BASE_PLANE_H);
    const imageMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0
    });
    const imageMesh = new THREE.Mesh(imageGeo, imageMat);
    imageMesh.visible = false;
    treeGroup.add(imageMesh);

    // --- BORDER FRAME THAT RESIZES TO IMAGE ---
    const frame = {
      w: BASE_PLANE_W,
      h: BASE_PLANE_H,
      margin: 0.25
    };

    // --- Star Topper ---
    const topperMat = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      emissive: 0xffd700,
      emissiveIntensity: 0.9,
      metalness: 0.85,
      roughness: 0.12
    });
    const topper = new THREE.Mesh(octaGeo, topperMat);
    topper.position.y = 4.5;
    treeGroup.add(topper);

    // --- POSITIONS & COLOR GENERATION ---
    const sphereData = [];
    const cubeData = [];
    const dummy = new THREE.Object3D();
    const _color = new THREE.Color();

    // Classic Christmas ornament palette (weighted)
    const PALETTE = [
      0x0b3d1e, 0x0b3d1e, 0x0b3d1e,
      0xc1121f, 0xc1121f,
      0xffd700, 0xffd700,
      0xe6e6e6, 0xe6e6e6,
      0xfff4d6
    ];

    function getRandomColor() {
      return PALETTE[Math.floor(Math.random() * PALETTE.length)];
    }

    function generateTreePos(i, total) {
      const angle = i * 0.5 + Math.random() * 0.5;
      const h = (i / total) * 9 - 4.5;
      const hNorm = (h + 4.5) / 9;
      const radius = (1 - hNorm) * 3.5 + 0.2;
      const r = radius * Math.sqrt(Math.random());
      return { x: r * Math.cos(angle * 10), y: h, z: r * Math.sin(angle * 10) };
    }

    function generateExplodePos() {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = 9 + Math.random() * 8;
      return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
    }

    // Border uses normalized parameter t (0..1) so it can resize dynamically
    function generateBorderT(i, total) {
      return { t: i / total, z: (Math.random() - 0.5) * 0.5 };
    }

    function borderPosFromT(t, w, h, z) {
      const perimeter = 2 * (w + h);
      const dist = t * perimeter;
      let x, y;

      if (dist < w) {
        x = dist - w / 2; y = -h / 2;
      } else if (dist < w + h) {
        x = w / 2; y = (dist - w) - h / 2;
      } else if (dist < 2 * w + h) {
        x = w / 2 - (dist - (w + h)); y = h / 2;
      } else {
        x = -w / 2; y = h / 2 - (dist - (2 * w + h));
      }
      return { x, y, z };
    }

    function initData(count, mesh, dataArray) {
      for (let i = 0; i < count; i++) {
        _color.setHex(getRandomColor());
        mesh.setColorAt(i, _color);

        const treePos = generateTreePos(i, count);
        const explodePos = generateExplodePos();
        const borderInfo = generateBorderT(i, count);

        const rot = { x: Math.random() * Math.PI, y: Math.random() * Math.PI, z: Math.random() * Math.PI };

        dataArray.push({
          curr: { x: treePos.x, y: treePos.y, z: treePos.z, rx: rot.x, ry: rot.y, rz: rot.z },
          tree: { x: treePos.x, y: treePos.y, z: treePos.z },
          explode: { x: explodePos.x, y: explodePos.y, z: explodePos.z },
          borderT: borderInfo.t,
          borderZ: borderInfo.z,
          rot: rot
        });

        dummy.position.set(treePos.x, treePos.y, treePos.z);
        dummy.rotation.set(rot.x, rot.y, rot.z);
        dummy.scale.set(1, 1, 1);
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
      }
      mesh.instanceMatrix.needsUpdate = true;
    }

    initData(SPHERE_COUNT, iMeshSpheres, sphereData);
    initData(CUBE_COUNT, iMeshCubes, cubeData);

    // --- INTERACTION LOGIC ---
    let currentState = 0; // 0=Tree, 1=Exploded, 2=Gallery
    let isAnimating = false;
    let currentImageIndex = 0;

    let downTime = 0;
    let startX = 0, startY = 0;

    window.addEventListener('pointerdown', (e) => {
      downTime = Date.now();
      startX = e.clientX;
      startY = e.clientY;
    });

    window.addEventListener('pointerup', (e) => {
      const timeDiff = Date.now() - downTime;
      const dist = Math.hypot(e.clientX - startX, e.clientY - startY);

      const music = document.getElementById('bg-music');
      if (music.paused) music.play().catch(() => {});

      if (timeDiff < 300 && dist < 15) handleClick();
    });

    function handleClick() {
      if (isAnimating) return;

      if (currentState === 0) {
        animateToState(1, 0, 1.5, "power2.out");
        currentState = 1;
      } else if (currentState === 1) {
        animateToState(2, 1, 1.5, "elastic.out(1, 0.5)");
        showGallery3D(true);
        currentState = 2;
      } else if (currentState === 2) {
        showGallery3D(false);
        isAnimating = true;

        const progressObj = { val: 0 };

        gsap.to(progressObj, {
          val: 1,
          duration: 0.8,
          ease: "power2.inOut",
          onUpdate: () => updateParticlesInterpolated(progressObj.val, 2, 1),
          onComplete: () => {
            progressObj.val = 0;
            gsap.to(progressObj, {
              val: 1,
              duration: 2.5,
              ease: "elastic.out(1, 0.4)",
              onUpdate: () => updateParticlesInterpolated(progressObj.val, 1, 0),
              onComplete: () => {
                syncCurrentPositions(0);
                isAnimating = false;
                currentState = 0;
              }
            });
          }
        });
      }
    }

    function showGallery3D(show) {
      if (show) {
        const url = IMAGE_SOURCES[currentImageIndex];
        currentImageIndex = (currentImageIndex + 1) % IMAGE_SOURCES.length;

        imageMesh.visible = true;

        textureLoader.load(url, (texture) => {
          imageMesh.material.map = texture;
          imageMesh.material.needsUpdate = true;

          // Resize plane to match image aspect
          const imgW = texture.image.width;
          const imgH = texture.image.height;
          const aspect = imgW / imgH;

          const newH = BASE_PLANE_H;
          const newW = newH * aspect;

          imageMesh.scale.set(newW / BASE_PLANE_W, newH / BASE_PLANE_H, 1);

          // Animate border to match
          gsap.to(frame, { w: newW, h: newH, duration: 0.8, ease: "power2.out" });

          gsap.to(imageMesh.material, { opacity: 1, duration: 1 });
        });
      } else {
        gsap.to(imageMesh.material, {
          opacity: 0,
          duration: 0.5,
          onComplete: () => { imageMesh.visible = false; }
        });
      }
    }

    function animateToState(targetStateIdx, fromStateIdxOverride = null, duration = 2.0, ease = "power2.out") {
      isAnimating = true;
      const progressObj = { val: 0 };
      const fromState = fromStateIdxOverride !== null ? fromStateIdxOverride : currentState;

      gsap.to(progressObj, {
        val: 1,
        duration: duration,
        ease: ease,
        onUpdate: () => updateParticlesInterpolated(progressObj.val, fromState, targetStateIdx),
        onComplete: () => {
          isAnimating = false;
          syncCurrentPositions(targetStateIdx);
        }
      });
    }

    function getPosForState(d, stateIdx) {
      if (stateIdx === 0) return d.tree;
      if (stateIdx === 1) return d.explode;

      if (stateIdx === 2) {
        const w = frame.w + frame.margin * 2;
        const h = frame.h + frame.margin * 2;
        return borderPosFromT(d.borderT, w, h, d.borderZ);
      }
      return d.tree;
    }

    function updateParticlesInterpolated(t, fromStateIdx, toStateIdx) {
      const updateMesh = (count, mesh, data, scaleMult = 1) => {
        for (let i = 0; i < count; i++) {
          const d = data[i];
          const fromPos = getPosForState(d, fromStateIdx);
          const toPos = getPosForState(d, toStateIdx);

          dummy.position.set(
            fromPos.x + (toPos.x - fromPos.x) * t,
            fromPos.y + (toPos.y - fromPos.y) * t,
            fromPos.z + (toPos.z - fromPos.z) * t
          );

          dummy.rotation.set(
            d.rot.x + t * (toStateIdx === 1 ? 2 : 1),
            d.rot.y + t * (toStateIdx === 1 ? 2 : 1),
            d.rot.z
          );

          const fromS = fromStateIdx === 2 ? 1.5 : 1;
          const toS = toStateIdx === 2 ? 1.5 : 1;
          const s = (fromS + (toS - fromS) * t) * scaleMult;

          dummy.scale.set(s, s, s);
          dummy.updateMatrix();
          mesh.setMatrixAt(i, dummy.matrix);
        }
        mesh.instanceMatrix.needsUpdate = true;
      };

      updateMesh(SPHERE_COUNT, iMeshSpheres, sphereData, 1.0);
      updateMesh(CUBE_COUNT, iMeshCubes, cubeData, 1.0);
    }

    function syncCurrentPositions(stateIdx) {
      const updateData = (arr) => {
        arr.forEach(d => {
          const tpos = getPosForState(d, stateIdx);
          d.curr.x = tpos.x;
          d.curr.y = tpos.y;
          d.curr.z = tpos.z;
        });
      };
      updateData(sphereData);
      updateData(cubeData);
    }

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();

      if (!isAnimating) {
        if (currentState === 0) {
          treeGroup.rotation.y = time * 0.1;
          topper.rotation.y = -time * 0.5;
        } else if (currentState === 1) {
          treeGroup.rotation.y += 0.002;
        } else if (currentState === 2) {
          treeGroup.rotation.y += 0.005;
        }
      }

      topper.position.y = 4.5 + Math.sin(time * 2) * 0.1;

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
